# Implementation Plan: Full-Stack Multi-User Todo Web Application (All Features)

**Branch**: `002-fullstack-web-all-features` | **Date**: 2026-01-01 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `phase2/specs/002-fullstack-web-all-features/spec.md`

## Summary

Build a production-ready, multi-user todo web application that migrates ALL Phase 1 features (Basic + Intermediate + Advanced) to a web interface with authentication, persistent storage, and modern cloud-native architecture. The application will support user registration/authentication, complete CRUD operations, priorities, tags, search/filter/sort, recurring tasks, and due date reminders with browser push notifications.

**Technical Approach**: Next.js 16+ App Router frontend with TypeScript and Tailwind CSS, FastAPI backend with SQLModel ORM, Neon PostgreSQL serverless database, Better Auth for JWT authentication, and Web Push API for notifications. Full user isolation enforced at database query level with JWT-based authorization.

## Technical Context

**Language/Version**:
- Frontend: TypeScript 5.3+ with Next.js 16+ (App Router)
- Backend: Python 3.13+ with UV package manager

**Primary Dependencies**:
- Frontend: Next.js 16, React 19, TypeScript, Tailwind CSS, Better Auth (client), Zod (validation)
- Backend: FastAPI, SQLModel, Pydantic v2, Better Auth (JWT verification), asyncpg (PostgreSQL driver), APScheduler (reminder cron job)

**Storage**:
- Neon PostgreSQL (serverless) with asyncpg driver
- Tables: users, tasks, notifications
- Foreign keys enforced: tasks.user_id ‚Üí users.id, notifications.user_id ‚Üí users.id, notifications.task_id ‚Üí tasks.id
- Indexes on: users.email, tasks.user_id, tasks.completed, tasks.created_at, tasks.due_date

**Testing**:
- Frontend: Jest + React Testing Library for components
- Backend: pytest + pytest-asyncio for async tests
- Contract tests for API endpoints
- Integration tests for auth flow and task CRUD with real database (Neon test instance)

**Target Platform**:
- Development: localhost:3000 (frontend), localhost:8000 (backend)
- Production: Vercel (frontend), Cloud hosting (backend), Neon PostgreSQL (database)
- Browser support: Chrome, Firefox, Safari (desktop and mobile)

**Project Type**: Web application (frontend + backend)

**Performance Goals**:
- API response time: <200ms (p95) per constitution SC-012
- Database queries: <50ms (p95)
- Frontend bundle: <500KB gzipped
- Task list render: <2 seconds for 100+ tasks (SC-015)
- Search results: <1 second for 10,000+ tasks (SC-018)
- Reminder delivery: <60 seconds of scheduled time (SC-019)

**Constraints**:
- Zero hardcoded credentials (all via .env)
- Async/await for all I/O operations (no synchronous DB calls)
- JWT tokens expire in 7 days
- Complete user isolation (user_id filtering on every query)
- No browser storage APIs (localStorage/sessionStorage) per constitution
- Type hints required on all Python functions
- Progressive enhancement (each phase builds on previous without breaking changes)

**Scale/Scope**:
- 10 user stories (P0-P9 priorities)
- 97 functional requirements (FR-001 to FR-097)
- 25 success criteria (SC-001 to SC-025)
- 3 database tables (users, tasks, notifications)
- ~15 API endpoints (auth + task CRUD + notifications)
- Responsive UI (mobile <640px, tablet 640-1024px, desktop >1024px)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Core Principles Compliance

‚úÖ **I. Spec-First Development**: This plan follows approved spec (spec.md), will generate detailed tasks.md before implementation
‚úÖ **II. AI-Native Architecture**: 100% of code will be generated by Claude Code per constitution requirement
‚úÖ **III. Cloud-Native Design**: Stateless FastAPI backend, Neon serverless PostgreSQL, designed for horizontal scaling (Phase IV Kubernetes)
‚úÖ **IV. Progressive Enhancement**: Phase 2 extends Phase 1 console features to web without breaking changes; database schema will evolve via migrations

### Technical Standards Compliance

‚úÖ **Code Quality**: Type hints on all Python functions, async/await for I/O, error handling on external calls, zero hardcoded credentials
‚úÖ **Database**: SQLModel for ORM, migrations tracked, foreign keys enforced, indexes on user_id and queried fields
‚úÖ **API Design**: RESTful conventions, JWT auth on all endpoints, JSON responses with consistent error structure, user isolation at query level
‚úÖ **AI/MCP (Phase III+)**: Not applicable to Phase 2, reserved for Phase 3 chatbot integration

### Technology Constraints Compliance

‚úÖ **Required Stack**: Python 3.13+ with UV ‚úì, Next.js 16+ App Router ‚úì, FastAPI + SQLModel ‚úì, Neon PostgreSQL ‚úì, Better Auth JWT ‚úì
‚ùå **Prohibited**: Manual code writing (will use Claude Code ‚úì), browser storage APIs (will use httpOnly cookies for JWT ‚úì), synchronous DB calls (all async ‚úì)

### Security Requirements Compliance

‚úÖ JWT tokens expire in 7 days (FR-012)
‚úÖ Passwords hashed by Better Auth (FR-004)
‚úÖ API keys in environment variables (FR-010, constitution)
‚úÖ CORS configured for frontend origin only (assumption #5)
‚úÖ Rate limiting deferred to post-Phase 2 (assumption #12 - acceptable for hackathon)

### Performance Targets Compliance

‚úÖ API response time: <200ms target aligns with FR-097 and SC-016 (<500ms p95)
‚úÖ Database queries: <50ms target aligns with SC-017 (<100ms p95)
‚úÖ Frontend bundle: <500KB target aligns with constitution
‚úÖ Kubernetes pod startup: Not applicable to Phase 2 (Phase IV requirement)

**Verdict**: ‚úÖ PASS - All applicable constitution requirements met. No violations requiring justification.

## Project Structure

### Documentation (this feature)

```text
phase2/specs/002-fullstack-web-all-features/
‚îú‚îÄ‚îÄ spec.md              # Feature specification (COMPLETE)
‚îú‚îÄ‚îÄ plan.md              # This file - implementation plan
‚îú‚îÄ‚îÄ tasks.md             # Generated by /sp.tasks (PENDING)
‚îú‚îÄ‚îÄ checklists/
‚îÇ   ‚îú‚îÄ‚îÄ requirements.md  # Requirements checklist (COMPLETE)
‚îÇ   ‚îî‚îÄ‚îÄ plan-quality-checklist.md  # Plan quality checklist (COMPLETE)
‚îî‚îÄ‚îÄ intelligence.md      # Phase 0 research output (TO BE CREATED)
```

### Source Code (repository root - phase2/)

```text
phase2/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py                    # FastAPI app entry point
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py                  # Environment config (DATABASE_URL, JWT_SECRET, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.py                # SQLModel async engine, session manager
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py                # User SQLModel (id, email, name, password_hash, timestamps)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task.py                # Task SQLModel (id, user_id, title, description, completed, priority, tags, recurrence, due_date, reminder_offset_minutes, parent_task_id, timestamps)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ notification.py        # Notification SQLModel (id, user_id, task_id, message, read, created_at)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py                # Pydantic schemas for SignupRequest, SigninRequest, TokenResponse
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task.py                # Pydantic schemas for TaskCreate, TaskUpdate, TaskResponse
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ notification.py        # Pydantic schemas for NotificationResponse
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py                # Better Auth integration, JWT verification, user registration/login
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task.py                # Task business logic (CRUD, filtering, sorting, recurring task creation)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ notification.py        # Notification creation, reminder checking
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ reminder_job.py        # APScheduler background job (runs every 60 sec, checks due tasks, creates notifications)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py                # POST /api/auth/signup, POST /api/auth/signin, POST /api/auth/signout
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tasks.py               # REST endpoints: GET/POST /api/users/{user_id}/tasks, GET/PUT/DELETE /api/users/{user_id}/tasks/{task_id}, PATCH /api/users/{user_id}/tasks/{task_id}/complete
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ notifications.py       # GET /api/users/{user_id}/notifications, PATCH /api/users/{user_id}/notifications/{notification_id}/read
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ jwt_auth.py            # JWT verification middleware, extracts user_id from token
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ cors.py                # CORS configuration (allow frontend origin)
‚îÇ   ‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001_initial_schema.sql     # Create users, tasks, notifications tables with indexes and foreign keys
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md                  # Migration execution instructions
‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conftest.py                # Pytest fixtures (test database, async client, auth tokens)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_auth.py               # Auth endpoints: signup, signin, signout, JWT validation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_tasks.py              # Task CRUD: create, read, update, delete, complete/incomplete, ownership validation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_filters.py            # Search, filter by status/priority/tag, sort by created/title/priority/due_date
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_recurring.py          # Recurring task creation on completion, edge cases (month-end)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_reminders.py          # Reminder job, notification creation, due date validation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_integration.py        # End-to-end flows: signup ‚Üí create task ‚Üí complete recurring ‚Üí receive reminder ‚Üí signout
‚îÇ   ‚îú‚îÄ‚îÄ .env.example                   # Example environment variables
‚îÇ   ‚îú‚îÄ‚îÄ pyproject.toml                 # UV project config (dependencies: fastapi, sqlmodel, asyncpg, better-auth-python, apscheduler, pytest)
‚îÇ   ‚îî‚îÄ‚îÄ README.md                      # Backend setup instructions
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx             # Root layout (Better Auth provider, global styles)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx               # Landing page (hero, signup CTA, signout if authenticated)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signup/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx           # Signup page (form: name, email, password, validation)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signin/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx           # Signin page (form: email, password, error handling)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Main dashboard (task list, create form, search/filter/sort UI)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ layout.tsx         # Dashboard layout (auth guard, redirect if not authenticated)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ [...betterauth]/route.ts  # Better Auth API route handler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskList.tsx           # Task list component (displays tasks with status, priority badges, tags)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskCard.tsx           # Individual task card (checkbox, edit/delete icons, due date countdown, overdue indicator)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskForm.tsx           # Task create/edit form (title, description, priority, tags, recurrence, due date, reminder)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SearchBar.tsx          # Search input with debounce (filters by title/description)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FilterPanel.tsx        # Filter controls (status, priority, tag dropdowns)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SortDropdown.tsx       # Sort dropdown (created date, title, priority, due date)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NotificationBell.tsx   # Notification icon with unread count badge
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RecurrenceSelector.tsx # Recurrence config UI (type: daily/weekly/monthly, days for weekly)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts                 # API client functions (fetch with Authorization header, error handling)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts                # Better Auth client config, JWT storage in httpOnly cookie
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts               # TypeScript types (User, Task, Notification, Priority, RecurrenceType)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts               # Helper functions (formatDate, calculateCountdown, normalizeTags)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useTasks.ts            # React hook for task CRUD operations
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useFilters.ts          # React hook for search/filter/sort state management
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useNotifications.ts    # React hook for notification fetching and marking as read
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAuth.ts             # React hook for authentication state (from Better Auth)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ globals.css            # Tailwind CSS imports, custom styles
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service-worker.js          # Service Worker for push notifications (registers for Web Push API)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ manifest.json              # Web app manifest (for PWA, optional)
‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskList.test.tsx      # Unit tests for TaskList component
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskCard.test.tsx      # Unit tests for TaskCard component
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaskForm.test.tsx      # Unit tests for TaskForm component (validation, recurrence, due date)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ integration/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ dashboard.test.tsx     # Integration tests for dashboard (create, edit, delete, filter, sort)
‚îÇ   ‚îú‚îÄ‚îÄ .env.local.example             # Example environment variables (NEXT_PUBLIC_API_URL)
‚îÇ   ‚îú‚îÄ‚îÄ next.config.js                 # Next.js config
‚îÇ   ‚îú‚îÄ‚îÄ package.json                   # Dependencies (next, react, typescript, tailwindcss, better-auth, zod)
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json                  # TypeScript config
‚îÇ   ‚îú‚îÄ‚îÄ tailwind.config.js             # Tailwind CSS config (custom colors for priority badges)
‚îÇ   ‚îî‚îÄ‚îÄ README.md                      # Frontend setup instructions
‚îÇ
‚îú‚îÄ‚îÄ docker-compose.yml                 # Local development (optional: postgres container for local testing instead of Neon)
‚îî‚îÄ‚îÄ README.md                          # Phase 2 overview, setup instructions, demo video link
```

**Structure Decision**: Web application structure selected (Option 2 from template). Frontend and backend are separate projects under `phase2/` directory with independent package management (npm for frontend, UV for backend). This aligns with constitution file structure standards and supports independent deployment (Vercel for frontend, cloud hosting for backend).

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations detected. All constitution requirements met:
- ‚úÖ Required stack used (Python 3.13+ UV, Next.js 16+, FastAPI, SQLModel, Neon PostgreSQL, Better Auth)
- ‚úÖ Prohibited practices avoided (no manual code writing, no localStorage for JWT, no synchronous DB calls)
- ‚úÖ Type hints and async/await enforced
- ‚úÖ Cloud-native design with stateless backend and serverless database

**No complexity justification required.**

---

## Implementation Phases (for tasks.md generation)

The `/sp.tasks` command will break down implementation into testable, dependency-ordered tasks based on priority tiers:

### Phase 0: Environment Setup (Foundation)
- Initialize backend (UV project, FastAPI app, database connection)
- Initialize frontend (Next.js App Router, TypeScript, Tailwind)
- Configure Better Auth in both projects
- Set up Neon PostgreSQL database and connection strings
- Create database migrations (users, tasks, notifications tables with indexes)
- Configure CORS middleware on backend

### Phase 1: Authentication (P0 - Foundation)
- Implement user registration endpoint (POST /api/auth/signup)
- Implement user signin endpoint (POST /api/auth/signin)
- Implement JWT verification middleware
- Implement signout functionality
- Create signup page UI (form validation, error handling)
- Create signin page UI (form validation, error handling)
- Implement auth guard for dashboard routes
- Test auth flow (signup ‚Üí signin ‚Üí JWT validation ‚Üí signout)

### Phase 2: Task CRUD (P1-P3 - Core)
- Implement create task endpoint (POST /api/users/{user_id}/tasks)
- Implement get tasks endpoint (GET /api/users/{user_id}/tasks with user_id filtering)
- Implement update task endpoint (PUT /api/users/{user_id}/tasks/{task_id} with ownership check)
- Implement delete task endpoint (DELETE /api/users/{user_id}/tasks/{task_id} with ownership check)
- Implement complete/incomplete toggle (PATCH /api/users/{user_id}/tasks/{task_id}/complete)
- Create dashboard page with task list UI
- Create task form component (create/edit modes)
- Create task card component (checkbox, edit/delete icons)
- Test task CRUD operations and ownership validation

### Phase 3: Priorities and Tags (P4-P5 - Intermediate)
- Add priority field to task schema and database
- Update task form to include priority selector
- Update task card to display priority badges (üî¥ High, üü° Medium, üîµ Low)
- Add tags field to task schema (JSONB array)
- Update task form to include tag input (max 5, alphanumeric validation)
- Update task card to display tag badges (#tag)
- Test priority and tag features

### Phase 4: Search, Filter, Sort (P6-P7 - Intermediate)
- Implement search query parameter (filter by title/description)
- Implement filter query parameters (status, priority, tag)
- Implement sort query parameters (created_at, title, priority, due_date)
- Create search bar component with debounce
- Create filter panel component (dropdowns for status, priority, tag)
- Create sort dropdown component
- Implement "Clear filters" button
- Test search, filter, sort combinations (AND logic, URL query params)

### Phase 5: Recurring Tasks (P8 - Advanced)
- Add recurrence field to task schema (JSONB: type, interval, days)
- Implement recurring task logic (calculate next due date, create new occurrence on completion)
- Handle month-end edge cases (Jan 31 ‚Üí Feb 28/29)
- Add parent_task_id field for task history linking
- Create recurrence selector component (daily/weekly/monthly, day checkboxes for weekly)
- Update task completion handler to trigger recurring task creation
- Display recurrence badge (üîÑ Daily, üîÑ Weekly, üîÑ Monthly)
- Test recurring task creation and edge cases

### Phase 6: Due Dates and Reminders (P9 - Advanced)
- Add due_date and reminder_offset_minutes fields to task schema
- Implement due date validation (must be in future)
- Create APScheduler background job (runs every 60 seconds)
- Implement reminder checking logic (create notification when reminder time reached)
- Create notifications table and API endpoints
- Implement notification API (GET unread, PATCH mark as read)
- Create due date/time picker in task form
- Create reminder selector (15 min, 1 hour, 1 day, 1 week before)
- Display due date countdown and overdue indicator (‚ö†Ô∏è red background)
- Implement Service Worker for push notifications
- Create notification bell component with unread count
- Test reminder delivery and notification UI

### Phase 7: Testing and Polish
- Write contract tests for all API endpoints
- Write integration tests for complete user flows
- Write unit tests for frontend components
- Fix any bugs discovered during testing
- Optimize database queries (verify indexes used)
- Optimize frontend bundle size
- Test responsive UI on mobile/tablet/desktop
- Verify all 25 success criteria (SC-001 to SC-025) met
- Create demo video (<90 seconds)

---

## Key Architectural Decisions

### 1. Authentication Strategy: JWT with httpOnly Cookies
**Decision**: Use Better Auth library with JWT tokens stored in httpOnly cookies (not localStorage).

**Rationale**:
- Better Auth provides out-of-box JWT generation, verification, and password hashing
- httpOnly cookies prevent XSS attacks (JavaScript cannot access token)
- Constitution prohibits browser storage APIs (localStorage/sessionStorage)

**Alternatives Rejected**:
- localStorage: Vulnerable to XSS, prohibited by constitution
- Session-based auth: Requires server-side session storage, not stateless

**Implementation**: Frontend sends credentials to `/api/auth/signin`, backend returns JWT in Set-Cookie header with httpOnly flag. Frontend includes cookie automatically on subsequent requests.

### 2. User Isolation: JWT Claims + Database Filtering
**Decision**: Extract user_id from JWT claims and enforce ownership at database query level (filter by user_id).

**Rationale**:
- JWT user_id claim is tamper-proof (verified by signature)
- Database filtering ensures users never see other users' data (SC-013)
- API endpoints validate JWT user_id matches path parameter `/api/users/{user_id}/tasks`

**Alternatives Rejected**:
- Trust frontend user_id: Insecure, users could manipulate requests
- Row-level security (RLS): Neon supports RLS, but adds complexity; explicit filtering is simpler and more transparent

**Implementation**: Middleware extracts user_id from JWT, passes to route handlers. All task queries include `.where(Task.user_id == user_id)`.

### 3. Recurring Tasks: On-Completion Trigger
**Decision**: Create next occurrence immediately when recurring task is marked complete (not scheduled cron job).

**Rationale**:
- Simpler implementation: logic triggered by user action (complete button)
- User sees instant feedback: "‚úì Task completed. Next occurrence created for [date]"
- No risk of missed recurrences due to cron job failures

**Alternatives Rejected**:
- Scheduled cron job: More complex, requires tracking "last generated date", risk of duplicate/missed occurrences
- Client-side generation: Insecure, users could manipulate recurrence logic

**Implementation**: Backend `complete_task()` function checks if task has recurrence config, calculates next due date, creates new task with parent_task_id linking to completed task.

### 4. Reminders: Backend Cron Job + Push Notifications
**Decision**: Use APScheduler backend job (runs every 60 seconds) to check due tasks, create notification records, trigger push notifications via Web Push API.

**Rationale**:
- Backend job ensures reminders sent even if user not actively using app
- 60-second granularity acceptable for Phase 2 (SC-019 allows <60 seconds)
- Web Push API delivers notifications even when browser closed (Service Worker)

**Alternatives Rejected**:
- Frontend polling: Unreliable (user must have app open), drains battery
- Email notifications: Out of scope for Phase 2, requires email service integration
- Real-time WebSocket: Overcomplicated for Phase 2, deferred to Phase 3

**Implementation**: APScheduler job queries `tasks.where(due_date - now() == reminder_offset_minutes)`, creates notification record, sends push notification payload to frontend Service Worker.

### 5. Tags Storage: JSONB Array
**Decision**: Store tags as JSONB array in PostgreSQL (e.g., `["work", "urgent", "q1"]`).

**Rationale**:
- Flexible: supports up to 5 tags per task without schema changes
- Efficient filtering: PostgreSQL JSONB supports `@>` containment operator for tag filtering
- Simple validation: array length and alphanumeric check in Pydantic schema

**Alternatives Rejected**:
- Separate tags table with many-to-many join: Overcomplicated for max 5 tags per task
- Comma-separated string: Harder to query, validate, and prevent duplicates

**Implementation**: SQLModel field `tags: List[str] = Field(sa_column=Column(JSON, default=[]))`, Pydantic validation ensures max 5, alphanumeric, lowercase.

### 6. Sorting/Filtering: Query Parameters + Database Queries
**Decision**: Accept search/filter/sort as URL query parameters, execute filtering in database queries (not in-memory).

**Rationale**:
- Scalable: handles 10,000+ tasks without loading all into memory (SC-018)
- Bookmarkable: users can bookmark filtered views (FR-052)
- Database indexes: leverages indexes on user_id, completed, created_at, due_date for fast queries

**Alternatives Rejected**:
- In-memory filtering: Doesn't scale, loads all tasks into backend/frontend memory
- Separate search service (Elasticsearch): Overcomplicated for Phase 2, deferred to Phase 5 with Kafka

**Implementation**: FastAPI endpoint accepts `?search=meeting&status=completed&priority=high&sort=due_date&order=desc`, builds SQLModel query: `.where(Task.title.contains(search)).where(Task.completed == true).where(Task.priority == 'high').order_by(Task.due_date.desc())`.

---

## Risk Analysis

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Better Auth JWT integration complexity | Medium | High | Use Context7 MCP to fetch up-to-date Better Auth docs; allocate extra time for auth middleware testing |
| Web Push API browser compatibility | Low | Medium | Test on Chrome/Firefox/Safari; fallback to in-app notifications if push not supported |
| Recurring task edge cases (month-end) | Medium | Medium | Write comprehensive tests for Jan 31 ‚Üí Feb 28/29, May 31 ‚Üí Jun 30; use Python `calendar.monthrange()` |
| APScheduler job reliability | Low | Low | APScheduler is stable; log all reminder checks; add monitoring endpoint to verify job running |
| Neon PostgreSQL cold start latency | Low | Low | Neon serverless wakes in <1 second; acceptable for Phase 2; can switch to provisioned instance if needed |
| Frontend bundle size exceeds 500KB | Low | Medium | Use Next.js dynamic imports for heavy components (date picker, recurrence selector); monitor with Lighthouse |
| JWT expiration UX (7-day expiry) | Low | Low | Display "Session expired" message on 401, redirect to signin; refresh tokens deferred to future phase |
| Database migration conflicts | Low | High | Use single migration file for Phase 2 schema; document upgrade path from Phase 1 console app (separate database) |

---

## Testing Strategy

### Contract Tests (Backend)
- **Scope**: Verify API endpoints meet OpenAPI contract (request/response schemas, status codes)
- **Tools**: pytest + httpx async client
- **Coverage**: All 15 API endpoints (auth, tasks CRUD, notifications)

### Integration Tests (Backend)
- **Scope**: End-to-end flows with real database (Neon test instance)
- **Tools**: pytest + pytest-asyncio + SQLModel test fixtures
- **Coverage**: Signup ‚Üí signin ‚Üí create task ‚Üí complete recurring ‚Üí receive reminder ‚Üí signout

### Unit Tests (Frontend)
- **Scope**: Individual component behavior (TaskCard, TaskForm, FilterPanel)
- **Tools**: Jest + React Testing Library
- **Coverage**: Form validation, priority badges, tag input, recurrence selector

### Integration Tests (Frontend)
- **Scope**: Dashboard interactions (create, edit, delete, filter, sort)
- **Tools**: Jest + React Testing Library + MSW (Mock Service Worker for API mocking)
- **Coverage**: User flows in isolated frontend environment

### Performance Tests
- **Scope**: Verify API response times <200ms (p95) and database queries <50ms (p95)
- **Tools**: pytest-benchmark + SQLAlchemy query logging
- **Coverage**: Task list query with 1000 tasks, search with 10,000 tasks

### Success Criteria Validation
- **Scope**: Verify all 25 success criteria (SC-001 to SC-025) met
- **Tools**: Manual testing with demo script, automated where possible
- **Coverage**: All user stories (US1-US10), edge cases, performance targets

---

## Deployment Plan (Phase 2)

### Development Environment
- Frontend: `npm run dev` (localhost:3000)
- Backend: `uvicorn src.main:app --reload` (localhost:8000)
- Database: Neon PostgreSQL (shared dev instance)

### Production Environment (Hackathon Demo)
- Frontend: Vercel (automatic deployment from `002-fullstack-web-all-features` branch)
- Backend: Railway / Render / DigitalOcean App Platform (containerized FastAPI)
- Database: Neon PostgreSQL (production instance with connection pooling)
- Environment Variables: Set in Vercel/Railway dashboard (DATABASE_URL, JWT_SECRET, NEXT_PUBLIC_API_URL)

### Monitoring (Minimal for Phase 2)
- Vercel Analytics: Track frontend performance
- Backend logs: Stdout logs captured by hosting platform
- Database: Neon dashboard for query performance monitoring
- Uptime: Manual verification (no automated alerting for Phase 2)

---

## Next Steps

1. ‚úÖ **Spec Complete**: User stories, functional requirements, success criteria documented
2. ‚úÖ **Plan Complete**: Technical architecture, structure, decisions, risks documented
3. ‚è≠Ô∏è **Generate Tasks**: Run `/sp.tasks` to create dependency-ordered task list (tasks.md)
4. ‚è≠Ô∏è **Create ADRs**: If significant decisions identified during planning, run `/sp.adr` for each decision (e.g., "JWT httpOnly Cookie Strategy", "Recurring Task On-Completion Trigger")
5. ‚è≠Ô∏è **Implementation**: Execute tasks from tasks.md using Claude Code (TDD: write tests ‚Üí approve ‚Üí implement)
6. ‚è≠Ô∏è **Demo Video**: Record <90 second demo showing all 10 user stories in action
7. ‚è≠Ô∏è **Commit & PR**: Create commit and pull request with demo video link

---

**Ready for `/sp.tasks` command to generate actionable task list.**
