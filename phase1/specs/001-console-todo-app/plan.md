# Implementation Plan: Console Todo App

**Branch**: `001-console-todo-app` | **Date**: 2025-12-31 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `phase1/specs/001-console-todo-app/spec.md`

## Summary

Building a Python command-line todo application with in-memory storage to demonstrate spec-driven development workflow. The application provides core CRUD operations (Create, Read, Update, Delete) for task management through an interactive CLI menu. This Phase I implementation focuses on basic functionality with no persistence, establishing the foundation for future phases that will add database storage and web interfaces.

**Technical Approach**: Two-component architecture with separation of concerns - `main.py` handles CLI interaction and user input validation, while `task_manager.py` provides business logic and in-memory data storage using Python lists.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: Python standard library only (datetime, os for terminal operations)
**Storage**: In-memory (Python list of dictionaries)
**Testing**: Manual validation against acceptance criteria (pytest deferred to Phase II)
**Target Platform**: Cross-platform CLI (WSL 2, Linux, macOS)
**Project Type**: Single project (console application)
**Performance Goals**: Handle 100+ tasks without noticeable lag (<3 seconds list view)
**Constraints**: Zero external dependencies, in-memory only (data lost on exit), single-user
**Scale/Scope**: Demonstration application for hackathon (10-50 tasks typical usage)

## Constitution Check

*GATE: Must pass before implementation. Validates compliance with project constitution.*

### Core Principles

✅ **I. Spec-First Development**: Specification complete and approved (spec.md)
✅ **II. AI-Native Architecture**: All code will be generated by Claude Code
✅ **III. Cloud-Native Design**: N/A for Phase I (console app, no cloud deployment)
✅ **IV. Progressive Enhancement**: Phase I establishes foundation for Phase II web app

### Technical Standards

✅ **Code Quality**:
- Type hints required (all function signatures will include type annotations)
- Async/await: N/A (no I/O operations, console-only)
- Error handling: All external operations (user input) will have try/except blocks
- Zero hardcoded credentials: N/A (no authentication in Phase I)

✅ **Database**: N/A for Phase I (in-memory storage)

✅ **API Design**: N/A for Phase I (console CLI, not API-driven)

✅ **AI/MCP**: N/A for Phase I (introduced in Phase III)

### Technology Constraints

✅ **Required Stack**:
- Python 3.13+: Confirmed
- UV: Will use for package management (even with zero external deps)
- Other stack components: N/A for Phase I

✅ **Prohibited**:
- Manual code writing: Confirmed - Claude Code will generate 100% of code
- Browser storage APIs: N/A (console app)
- Synchronous database calls: N/A (no database)

### Result: ✅ PASSED - All applicable constitution requirements met

## Project Structure

### Documentation (this feature)

```text
phase1/specs/001-console-todo-app/
├── spec.md              # Feature specification (completed)
├── plan.md              # This file (implementation plan)
├── tasks.md             # Task breakdown (next: /sp.tasks command)
└── checklists/
    └── requirements.md  # Spec quality checklist (completed)
```

### Source Code

```text
phase1/src/
├── main.py              # CLI interface and menu loop
├── task_manager.py      # Business logic and data storage
└── __init__.py          # Package marker

phase1/
├── README.md            # Setup and usage instructions
├── pyproject.toml       # UV project configuration
└── .python-version      # Python version specification (3.13+)
```

**Structure Decision**: Single project structure selected. Phase I is a standalone console application with no web/mobile components. All source code resides in `phase1/src/` directory. No tests directory for Phase I (manual validation only); testing infrastructure will be added in Phase II when pytest is introduced.

## Complexity Tracking

> No constitution violations - section intentionally empty

## Architecture Overview

### Component Diagram

```
┌──────────────────────────────────────────┐
│         main.py (CLI Interface)          │
│  ┌────────────────────────────────────┐  │
│  │ display_menu()                     │  │
│  │ get_user_choice() → validates 1-6  │  │
│  │ add_task_flow()                    │  │
│  │ view_tasks_flow()                  │  │
│  │ update_task_flow()                 │  │
│  │ delete_task_flow()                 │  │
│  │ toggle_complete_flow()             │  │
│  │ main() → event loop                │  │
│  └────────────────────────────────────┘  │
└──────────────┬───────────────────────────┘
               │ method calls
               ▼
┌──────────────────────────────────────────┐
│   task_manager.py (Business Logic)       │
│  ┌────────────────────────────────────┐  │
│  │ class TaskManager:                 │  │
│  │   tasks: list[dict]                │  │
│  │   next_id: int                     │  │
│  │                                    │  │
│  │   add_task()        → dict         │  │
│  │   get_all_tasks()   → list[dict]   │  │
│  │   get_task()        → dict | None  │  │
│  │   update_task()     → dict | None  │  │
│  │   delete_task()     → bool         │  │
│  │   toggle_complete() → dict | None  │  │
│  └────────────────────────────────────┘  │
└──────────────────────────────────────────┘
```

### Data Flow

**Create Task**:
```
User input → main.add_task_flow()
  → validates title (1-200 chars)
  → validates description (optional, max 1000 chars)
  → TaskManager.add_task(title, desc)
    → creates dict with ID, timestamps
    → appends to tasks list
    → returns task dict
  → main displays confirmation with ID
```

**View Tasks**:
```
User input → main.view_tasks_flow()
  → TaskManager.get_all_tasks()
    → returns tasks sorted by created_at (newest first)
  → main formats output:
      [✓] 1. Task Title (Completed) - Description preview...
      [ ] 2. Task Title (Pending) - Description preview...
```

**Update Task**:
```
User input → main.update_task_flow()
  → prompts for task ID
  → prompts for new title/description
  → TaskManager.update_task(id, title, desc)
    → finds task by ID
    → updates fields if provided
    → returns updated task or None
  → main shows before/after or error
```

**Delete Task**:
```
User input → main.delete_task_flow()
  → prompts for task ID
  → prompts for confirmation (y/n)
  → if confirmed: TaskManager.delete_task(id)
    → removes task from list
    → returns True/False
  → main shows success or error
```

**Toggle Complete**:
```
User input → main.toggle_complete_flow()
  → prompts for task ID
  → TaskManager.toggle_complete(id)
    → finds task, flips completed boolean
    → returns updated task or None
  → main shows new status or error
```

## Component Details

### Component 1: main.py (CLI Interface)

**Responsibilities**:
- Display interactive menu (1-6 options + Exit)
- Capture and validate user input
- Route commands to TaskManager methods
- Format output messages and task displays
- Handle the main event loop

**Key Functions**:

```python
def display_menu() -> None:
    """Display numbered menu options"""

def get_user_choice() -> str:
    """Prompt for menu choice, validate 1-6, return choice"""

def add_task_flow(manager: TaskManager) -> None:
    """Prompt for title/description, call add_task(), show confirmation"""

def view_tasks_flow(manager: TaskManager) -> None:
    """Call get_all_tasks(), format and display list"""

def update_task_flow(manager: TaskManager) -> None:
    """Prompt for ID and new data, call update_task(), show result"""

def delete_task_flow(manager: TaskManager) -> None:
    """Prompt for ID and confirmation, call delete_task(), show result"""

def toggle_complete_flow(manager: TaskManager) -> None:
    """Prompt for ID, call toggle_complete(), show result"""

def main() -> None:
    """Initialize TaskManager, run menu loop until exit"""
```

**Input Validation Rules**:
- Menu choice: Must be "1", "2", "3", "4", "5", or "6"
- Title: Required, 1-200 characters
- Description: Optional, max 1000 characters
- Task ID: Must be positive integer
- Confirmation: Must be "y" or "n" (case-insensitive)

### Component 2: task_manager.py (Business Logic)

**Responsibilities**:
- Store tasks in memory (list of dictionaries)
- Generate unique auto-incrementing IDs
- Perform CRUD operations
- Return success/error indicators (dict/None/bool)

**Class Definition**:

```python
from datetime import datetime
from typing import Optional

class TaskManager:
    def __init__(self) -> None:
        """Initialize empty task list and ID counter"""
        self.tasks: list[dict] = []
        self.next_id: int = 1

    def add_task(self, title: str, description: str = "") -> dict:
        """
        Create new task with unique ID.

        Args:
            title: Task title (1-200 chars, validated by caller)
            description: Optional description (max 1000 chars)

        Returns:
            Created task dictionary
        """

    def get_all_tasks(self) -> list[dict]:
        """
        Retrieve all tasks ordered by creation time (newest first).

        Returns:
            List of task dictionaries (empty list if none)
        """

    def get_task(self, task_id: int) -> Optional[dict]:
        """
        Find task by ID.

        Args:
            task_id: Task ID to find

        Returns:
            Task dictionary if found, None otherwise
        """

    def update_task(
        self,
        task_id: int,
        title: Optional[str] = None,
        description: Optional[str] = None
    ) -> Optional[dict]:
        """
        Update task title and/or description.

        Args:
            task_id: Task ID to update
            title: New title (None = no change)
            description: New description (None = no change)

        Returns:
            Updated task dictionary if found, None otherwise
        """

    def delete_task(self, task_id: int) -> bool:
        """
        Remove task from list.

        Args:
            task_id: Task ID to delete

        Returns:
            True if deleted, False if not found
        """

    def toggle_complete(self, task_id: int) -> Optional[dict]:
        """
        Toggle task completion status.

        Args:
            task_id: Task ID to toggle

        Returns:
            Updated task dictionary if found, None otherwise
        """
```

**Data Structure**:

```python
task = {
    "id": 1,                                    # int: Auto-increment ID
    "title": "Buy groceries",                   # str: 1-200 chars
    "description": "Milk, eggs, bread",         # str: optional, max 1000
    "completed": False,                         # bool: default False
    "created_at": "2025-12-31T10:30:00.123456"  # str: ISO format timestamp
}
```

## Key Design Decisions

### Decision 1: Storage Structure (List vs Dictionary)

**Options Considered**:
1. **List of dictionaries** (chosen)
   - Pro: Natural ordering, simple iteration
   - Con: O(n) lookups by ID
2. **Dictionary with ID as key**
   - Pro: O(1) lookups
   - Con: No natural ordering, need separate sort

**Trade-offs**: Dictionary faster for lookups, but list simpler and ordering matters for display.

**Decision**: Use list of dictionaries. Performance difference negligible for Phase I scope (100 tasks max). Simpler code and natural ordering by creation time outweigh lookup speed benefits.

**Rationale**: Specification requires "Tasks ordered by creation time (newest first)" (FR-006). List maintains insertion order, simplifying this requirement.

---

### Decision 2: ID Generation Strategy

**Options Considered**:
1. **Auto-incrementing counter** (chosen)
   - Pro: Simple, predictable, human-readable
   - Con: No collision protection across sessions
2. **UUID**
   - Pro: Globally unique, no collisions
   - Con: Not human-readable, overkill for Phase I

**Trade-offs**: Counter simpler and user-friendly, UUID prevents collisions but unnecessary for single-session in-memory storage.

**Decision**: Use auto-incrementing integer counter starting at 1.

**Rationale**: Phase I has no persistence (data lost on exit), so collision risk is zero. User-friendly IDs improve demo experience for hackathon judges.

---

### Decision 3: Input Validation Location

**Options Considered**:
1. **Validate in main.py** (chosen)
   - Pro: Separation of concerns (UI validates, business logic trusts)
   - Con: Some duplication if multiple UIs added
2. **Validate in TaskManager**
   - Pro: DRY principle, centralized validation
   - Con: Mixes business logic with input validation

**Trade-offs**: UI-layer validation vs centralized validation.

**Decision**: Validate all user input in `main.py` before calling TaskManager methods.

**Rationale**: TaskManager remains pure business logic, testable without UI concerns. Phase II will add web UI with different validation needs (HTML forms), so UI-specific validation makes sense.

---

### Decision 4: Error Handling Strategy

**Options Considered**:
1. **Return None/False for errors** (chosen)
   - Pro: Simple, explicit checks in caller
   - Con: Less informative than exceptions
2. **Raise exceptions**
   - Pro: Better error messages, stack traces
   - Con: Adds complexity for simple CLI

**Trade-offs**: Simplicity vs detailed error reporting.

**Decision**: TaskManager methods return None (for not found) or False (for failures). No exceptions raised.

**Rationale**: CLI application can provide user-friendly messages directly. Exception handling adds overhead unnecessary for Phase I scope. Phase II API will benefit from exceptions, but Phase I prioritizes simplicity.

---

### Decision 5: Terminal Clearing Behavior

**Options Considered**:
1. **Clear screen between operations** (not chosen)
   - Pro: Clean UI, focused view
   - Con: Loses history, harder to debug
2. **Scroll output naturally** (chosen)
   - Pro: Preserves history, easier debugging
   - Con: Screen gets cluttered

**Trade-offs**: Clean UI vs development/demo ease.

**Decision**: Do NOT clear terminal. Let output scroll naturally.

**Rationale**: Demo context benefits from visible history. Judges can see full interaction flow. Easier to debug during development. If needed, users can manually clear terminal.

## Implementation Phases

### Phase 0: Project Setup
- Create `phase1/src/` directory structure
- Initialize `pyproject.toml` with UV
- Create `.python-version` file (3.13)
- Create empty `__init__.py`, `main.py`, `task_manager.py`

### Phase 1: Data Layer (TaskManager)
- Implement `TaskManager.__init__()` with empty tasks list
- Implement `add_task()` with ID generation
- Implement `get_all_tasks()` with sorting
- Implement `get_task()` for lookups
- Implement `update_task()` with field updates
- Implement `delete_task()` with list removal
- Implement `toggle_complete()` with boolean flip

### Phase 2: CLI Menu Framework
- Implement `display_menu()` with numbered options
- Implement `get_user_choice()` with validation
- Implement `main()` loop with exit condition
- Test menu displays and choice validation

### Phase 3: Core Operations (Add/View)
- Implement `add_task_flow()` with prompts and validation
- Implement `view_tasks_flow()` with formatting
- Test create and view workflows
- Verify empty list message

### Phase 4: Modify Operations (Update/Delete/Toggle)
- Implement `update_task_flow()` with before/after display
- Implement `delete_task_flow()` with confirmation
- Implement `toggle_complete_flow()` with status display
- Test all modify operations

### Phase 5: Polish and Documentation
- Add docstrings to all functions
- Create README.md with setup/run instructions
- Test all acceptance criteria from spec.md
- Verify all 10 success criteria met

## Validation & Testing Strategy

### Manual Validation Checklist

**User Story 1: Create and View Tasks (P1)**
- [ ] Create task with title only → verify ID assigned, status "pending"
- [ ] Create task with title + description → verify both stored
- [ ] View empty list → verify message "No tasks yet!"
- [ ] View 3+ tasks → verify newest first, all fields displayed
- [ ] Verify description preview truncated to 50 chars

**User Story 2: Mark Tasks Complete (P2)**
- [ ] Mark pending task complete → verify status changes, [✓] shown
- [ ] Mark completed task incomplete → verify status reverts, [ ] shown
- [ ] Attempt to mark non-existent ID → verify error "Task ID X not found"

**User Story 3: Update Task Details (P3)**
- [ ] Update task title → verify before/after displayed, change persists
- [ ] Update task description → verify change persists
- [ ] Update non-existent task → verify error message

**User Story 4: Delete Tasks (P4)**
- [ ] Delete task with confirmation → verify removed from list
- [ ] Attempt delete with "n" confirmation → verify task remains
- [ ] Delete non-existent task → verify error message

### Edge Cases Validation
- [ ] Title with exactly 200 characters (max length)
- [ ] Description with exactly 1000 characters (max length)
- [ ] Empty title input → verify error
- [ ] Invalid menu choice (e.g., "7", "abc") → verify error
- [ ] Create 100 tasks → verify list view <3 seconds

### Success Criteria Validation
- [ ] SC-001: Create task in <10 seconds
- [ ] SC-002: View list in <3 seconds
- [ ] SC-003: Mark complete in <5 seconds
- [ ] SC-004: Update task in <15 seconds
- [ ] SC-005: Delete task in <10 seconds
- [ ] SC-006: Handle 100 tasks without degradation
- [ ] SC-007: All operations provide immediate feedback
- [ ] SC-008: Full workflow demo in <90 seconds
- [ ] SC-009: Zero crashes during normal operation
- [ ] SC-010: Runs on WSL 2, Linux, macOS

## README.md Content Outline

```markdown
# Phase I: Console Todo App

Simple command-line todo application with in-memory storage.

## Requirements
- Python 3.13+
- UV package manager

## Setup
```bash
cd phase1
uv sync
```

## Usage
```bash
cd phase1
python src/main.py
```

## Features
- Add tasks with title and description
- View all tasks (ordered by creation time)
- Update task details
- Delete tasks (with confirmation)
- Mark tasks complete/incomplete

## Limitations
- In-memory only (data lost on exit)
- No persistent storage (coming in Phase II)
- Single-user only
```

## Next Steps

After plan approval:
1. Run `/sp.tasks` to generate detailed task breakdown
2. Run `/sp.implement` to execute implementation
3. Manual validation against acceptance criteria
4. Create demo video (<90 seconds)
5. Proceed to Phase II planning (web application with persistence)
