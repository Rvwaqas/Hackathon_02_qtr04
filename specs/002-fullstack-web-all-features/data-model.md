# Data Model - Phase II: Full-Stack Todo Application

**Feature**: Full-Stack Todo Web Application (All Features)
**Branch**: 002-fullstack-web-all-features
**Date**: 2026-01-01

## Entity Relationship Diagram

```
┌─────────────────────────────────────┐
│             User                    │
│  (Managed by Better Auth)           │
├─────────────────────────────────────┤
│ id: string (PK)                     │
│ email: string (unique)              │
│ name: string                        │
│ created_at: datetime                │
└──────────────┬──────────────────────┘
               │
               │ 1:N
               │
       ┌───────┴────────┐
       │                │
       ▼                ▼
┌──────────────────────────────────────┐    ┌──────────────────────────────────────┐
│             Task                     │    │         Notification                 │
├──────────────────────────────────────┤    ├──────────────────────────────────────┤
│ id: int (PK, auto)                   │◄───│ task_id: int (FK)                    │
│ user_id: string (FK → User.id)       │    │ id: int (PK, auto)                   │
│ title: string                        │    │ user_id: string (FK → User.id)       │
│ description: string | null           │    │ message: string                      │
│ completed: bool = False              │    │ read: bool = False                   │
│ priority: string = "none"            │    │ created_at: datetime                 │
│ tags: list[str] = [] (JSONB)         │    └──────────────────────────────────────┘
│ recurrence: dict | None (JSONB)      │
│ due_date: datetime | null            │
│ reminder_offset_minutes: int | null  │
│ parent_task_id: int | null (FK)      │─┐
│ created_at: datetime                 │ │
│ updated_at: datetime                 │ │
└──────────────────────────────────────┘ │
                │                         │
                └─────────────────────────┘
                  Self-referential FK
                  (recurring tasks)
```

---

## Entity Definitions

### 1. User

**Purpose**: Represents an authenticated user account. Managed entirely by Better Auth.

**Source**: Better Auth `user` table (read-only for our application)

**Attributes**:

| Field        | Type     | Constraints          | Description                                    |
|-------------|----------|----------------------|------------------------------------------------|
| `id`        | string   | PRIMARY KEY          | UUID generated by Better Auth                  |
| `email`     | string   | UNIQUE, NOT NULL     | User's email address (used for login)          |
| `name`      | string   | NOT NULL             | User's display name                            |
| `created_at`| datetime | NOT NULL, auto       | Account creation timestamp                     |

**Relationships**:
- **1:N** with `Task` (one user has many tasks)
- **1:N** with `Notification` (one user has many notifications)

**Indexes**:
- PRIMARY KEY on `id` (automatic)
- UNIQUE INDEX on `email` (automatic via Better Auth)

**Notes**:
- We DO NOT create or modify users directly - Better Auth handles all user management
- Password hashing, email verification handled by Better Auth
- For API operations, we only READ from this table to verify `user_id` exists

**SQLModel Representation** (Read-Only):
```python
from sqlmodel import SQLModel, Field
from datetime import datetime

class User(SQLModel, table=True):
    """Read-only model for Better Auth user table"""
    __tablename__ = "user"  # Better Auth default table name

    id: str = Field(primary_key=True)
    email: str = Field(unique=True, index=True)
    name: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

---

### 2. Task

**Purpose**: Represents a todo item with full feature set (basic, intermediate, advanced)

**Table**: `tasks`

**Attributes**:

| Field                      | Type            | Constraints                          | Description                                                  |
|---------------------------|-----------------|--------------------------------------|--------------------------------------------------------------|
| `id`                      | int             | PRIMARY KEY, AUTO INCREMENT          | Unique task identifier                                       |
| `user_id`                 | string          | FOREIGN KEY → User.id, NOT NULL      | Owner of the task                                            |
| `title`                   | string          | NOT NULL                             | Task title (max 200 chars)                                   |
| `description`             | string          | NULL                                 | Optional detailed description (max 2000 chars)               |
| `completed`               | bool            | NOT NULL, DEFAULT FALSE              | Completion status                                            |
| `priority`                | string          | DEFAULT "none"                       | Priority level: "high", "medium", "low", "none"              |
| `tags`                    | list[str]       | JSONB, DEFAULT []                    | Array of tag strings, e.g., ["work", "urgent"]               |
| `recurrence`              | dict            | JSONB, NULL                          | Recurrence configuration (see Recurrence Schema below)       |
| `due_date`                | datetime        | NULL                                 | When task is due (with time component)                       |
| `reminder_offset_minutes` | int             | NULL, CHECK >= 0                     | Minutes before due_date to send reminder (5, 15, 30, 60)     |
| `parent_task_id`          | int             | FOREIGN KEY → Task.id, NULL          | ID of parent task (for recurring task audit trail)           |
| `created_at`              | datetime        | NOT NULL, auto                       | Task creation timestamp                                      |
| `updated_at`              | datetime        | NOT NULL, auto                       | Last modification timestamp (auto-updated on save)           |

**Recurrence Schema** (JSONB):
```json
{
  "type": "daily" | "weekly" | "monthly",
  "interval": 1,  // Every N days/weeks/months
  "days": [1, 3, 5]  // Optional: For weekly, 1=Monday, 7=Sunday
}
```

**Examples**:
- Daily: `{"type": "daily", "interval": 1}` - Every day
- Every 2 days: `{"type": "daily", "interval": 2}`
- Weekly on Mon/Wed/Fri: `{"type": "weekly", "interval": 1, "days": [1, 3, 5]}`
- Monthly: `{"type": "monthly", "interval": 1}` - Same day each month

**Relationships**:
- **N:1** with `User` (many tasks belong to one user)
- **1:N** with `Notification` (one task can have many reminders)
- **Self-referential N:1** with `Task` (recurring tasks link to parent via `parent_task_id`)

**Indexes**:
- PRIMARY KEY on `id` (automatic)
- INDEX on `user_id` (for queries: "get all tasks for user X")
- INDEX on `completed` (for filters: "show only pending tasks")
- INDEX on `due_date` (for reminders: "tasks due soon")
- GIN INDEX on `tags` (for JSONB queries: "tasks with tag 'work'")

**Constraints**:
- CHECK: `priority IN ('high', 'medium', 'low', 'none')`
- CHECK: `reminder_offset_minutes >= 0` (cannot be negative)
- CHECK: If `reminder_offset_minutes` IS NOT NULL, then `due_date` MUST NOT be NULL

**State Transitions**:
```
[Created] ─────► [Pending] ─────► [Completed]
                     │                 │
                     └─────────────────┘
                          Toggle
```

**Business Rules**:
1. **User isolation**: All queries MUST filter by `user_id` to enforce data isolation
2. **Recurring logic**: When `completed` is set to TRUE AND `recurrence` IS NOT NULL, create next occurrence
3. **Reminder creation**: Background job checks `due_date - reminder_offset_minutes` and creates `Notification`
4. **Tag deduplication**: Frontend MUST prevent duplicate tags in array
5. **Month-end handling**: When `recurrence.type = "monthly"`, clamp to last valid day (e.g., Jan 31 → Feb 28)

**SQLModel Representation**:
```python
from sqlmodel import SQLModel, Field, Column
from sqlalchemy import JSON
from datetime import datetime
from typing import Optional

class TaskRecurrence(SQLModel):
    """Embedded recurrence configuration"""
    type: str  # "daily" | "weekly" | "monthly"
    interval: int = 1
    days: Optional[list[int]] = None

class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="user.id", index=True)
    title: str = Field(max_length=200)
    description: Optional[str] = Field(default=None, max_length=2000)
    completed: bool = Field(default=False, index=True)
    priority: str = Field(default="none")
    tags: list[str] = Field(default=[], sa_column=Column(JSON))
    recurrence: Optional[dict] = Field(default=None, sa_column=Column(JSON))
    due_date: Optional[datetime] = Field(default=None, index=True)
    reminder_offset_minutes: Optional[int] = Field(default=None)
    parent_task_id: Optional[int] = Field(default=None, foreign_key="tasks.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

---

### 3. Notification

**Purpose**: Represents a reminder notification for a task with due date

**Table**: `notifications`

**Attributes**:

| Field        | Type     | Constraints                          | Description                                    |
|-------------|----------|--------------------------------------|------------------------------------------------|
| `id`        | int      | PRIMARY KEY, AUTO INCREMENT          | Unique notification identifier                 |
| `user_id`   | string   | FOREIGN KEY → User.id, NOT NULL      | Owner of the notification                      |
| `task_id`   | int      | FOREIGN KEY → Task.id, NOT NULL      | Task that triggered the notification           |
| `message`   | string   | NOT NULL                             | Notification text (e.g., "⏰ 'Task' is due soon!") |
| `read`      | bool     | NOT NULL, DEFAULT FALSE              | Whether user has acknowledged notification     |
| `created_at`| datetime | NOT NULL, auto                       | When notification was created                  |

**Relationships**:
- **N:1** with `User` (many notifications belong to one user)
- **N:1** with `Task` (many notifications can reference one task)

**Indexes**:
- PRIMARY KEY on `id` (automatic)
- INDEX on `user_id, read` (composite index for query: "get unread notifications for user")
- INDEX on `task_id` (for query: "find notification for task")

**Constraints**:
- CASCADE DELETE on `task_id` (if task deleted, delete its notifications)

**Business Rules**:
1. **Deduplication**: Before creating notification, check if unread notification exists for same `task_id`
2. **Polling**: Frontend polls `/api/{user_id}/notifications` every 30 seconds for `read=false`
3. **Badge count**: Display count of unread notifications in UI bell icon
4. **Mark read**: When user clicks notification, PATCH `/api/{user_id}/notifications/{id}` to set `read=true`

**SQLModel Representation**:
```python
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional

class Notification(SQLModel, table=True):
    __tablename__ = "notifications"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="user.id", index=True)
    task_id: int = Field(foreign_key="tasks.id")
    message: str = Field(max_length=500)
    read: bool = Field(default=False, index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

---

## Database Migrations

**Migration Tool**: Alembic (SQLModel-compatible)

**Initial Migration** (`001_initial_schema.py`):
```python
"""Create tasks and notifications tables

Revision ID: 001
"""

def upgrade():
    # Create tasks table
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer, primary_key=True),
        sa.Column('user_id', sa.String, sa.ForeignKey('user.id'), nullable=False),
        sa.Column('title', sa.String(200), nullable=False),
        sa.Column('description', sa.String(2000)),
        sa.Column('completed', sa.Boolean, default=False, nullable=False),
        sa.Column('priority', sa.String, default='none'),
        sa.Column('tags', JSON, default=[]),
        sa.Column('recurrence', JSON),
        sa.Column('due_date', sa.DateTime),
        sa.Column('reminder_offset_minutes', sa.Integer),
        sa.Column('parent_task_id', sa.Integer, sa.ForeignKey('tasks.id')),
        sa.Column('created_at', sa.DateTime, nullable=False),
        sa.Column('updated_at', sa.DateTime, nullable=False),
    )

    # Create indexes
    op.create_index('ix_tasks_user_id', 'tasks', ['user_id'])
    op.create_index('ix_tasks_completed', 'tasks', ['completed'])
    op.create_index('ix_tasks_due_date', 'tasks', ['due_date'])
    op.create_index('ix_tasks_tags_gin', 'tasks', ['tags'], postgresql_using='gin')

    # Create notifications table
    op.create_table(
        'notifications',
        sa.Column('id', sa.Integer, primary_key=True),
        sa.Column('user_id', sa.String, sa.ForeignKey('user.id'), nullable=False),
        sa.Column('task_id', sa.Integer, sa.ForeignKey('tasks.id', ondelete='CASCADE'), nullable=False),
        sa.Column('message', sa.String(500), nullable=False),
        sa.Column('read', sa.Boolean, default=False, nullable=False),
        sa.Column('created_at', sa.DateTime, nullable=False),
    )

    # Create indexes
    op.create_index('ix_notifications_user_id_read', 'notifications', ['user_id', 'read'])
    op.create_index('ix_notifications_task_id', 'notifications', ['task_id'])

def downgrade():
    op.drop_table('notifications')
    op.drop_table('tasks')
```

---

## Validation Rules

### Task Validation

**Title**:
- Required
- Min length: 1
- Max length: 200
- No leading/trailing whitespace

**Description**:
- Optional
- Max length: 2000
- Can contain markdown (frontend renders as plain text in Phase II)

**Priority**:
- Must be one of: "high", "medium", "low", "none"
- Default: "none"

**Tags**:
- Array of strings
- Each tag: min length 1, max length 30
- Max 10 tags per task
- No duplicates
- Alphanumeric + hyphens/underscores only

**Recurrence**:
- If present, must match `TaskRecurrence` schema
- `type`: Must be "daily", "weekly", or "monthly"
- `interval`: Must be >= 1 and <= 365
- `days`: If `type="weekly"`, must be array of 1-7 (Monday-Sunday)

**Due Date**:
- Must be in future (cannot create task due in past)
- If `reminder_offset_minutes` is set, `due_date` must also be set

**Reminder Offset**:
- Must be one of: 5, 15, 30, 60 (minutes)
- Cannot exceed time until due date

### Notification Validation

**Message**:
- Required
- Max length: 500

---

## Sample Data

**User** (managed by Better Auth):
```json
{
  "id": "usr_abc123xyz",
  "email": "alice@example.com",
  "name": "Alice Johnson",
  "created_at": "2026-01-01T10:00:00Z"
}
```

**Task Examples**:

**Basic Task**:
```json
{
  "id": 1,
  "user_id": "usr_abc123xyz",
  "title": "Write project proposal",
  "description": "Draft proposal for Q1 initiatives",
  "completed": false,
  "priority": "high",
  "tags": ["work", "urgent"],
  "recurrence": null,
  "due_date": "2026-01-05T17:00:00Z",
  "reminder_offset_minutes": 30,
  "parent_task_id": null,
  "created_at": "2026-01-01T10:00:00Z",
  "updated_at": "2026-01-01T10:00:00Z"
}
```

**Recurring Task**:
```json
{
  "id": 2,
  "user_id": "usr_abc123xyz",
  "title": "Daily standup",
  "description": null,
  "completed": false,
  "priority": "medium",
  "tags": ["work", "meeting"],
  "recurrence": {
    "type": "daily",
    "interval": 1
  },
  "due_date": "2026-01-02T09:00:00Z",
  "reminder_offset_minutes": 15,
  "parent_task_id": null,
  "created_at": "2026-01-01T10:00:00Z",
  "updated_at": "2026-01-01T10:00:00Z"
}
```

**Notification Example**:
```json
{
  "id": 1,
  "user_id": "usr_abc123xyz",
  "task_id": 1,
  "message": "⏰ 'Write project proposal' is due soon!",
  "read": false,
  "created_at": "2026-01-05T16:30:00Z"
}
```

---

## Query Patterns

### Common Queries (with SQLModel)

**1. Get all pending tasks for user**:
```python
tasks = session.exec(
    select(Task)
    .where(Task.user_id == user_id)
    .where(Task.completed == False)
    .order_by(Task.created_at.desc())
).all()
```

**2. Filter by priority**:
```python
tasks = session.exec(
    select(Task)
    .where(Task.user_id == user_id)
    .where(Task.priority == "high")
).all()
```

**3. Search by keyword** (title or description):
```python
search_term = f"%{keyword}%"
tasks = session.exec(
    select(Task)
    .where(Task.user_id == user_id)
    .where(
        (Task.title.ilike(search_term)) |
        (Task.description.ilike(search_term))
    )
).all()
```

**4. Filter by tag** (JSONB contains):
```python
tasks = session.exec(
    select(Task)
    .where(Task.user_id == user_id)
    .where(Task.tags.contains(["work"]))  # PostgreSQL JSONB operator
).all()
```

**5. Get tasks due soon** (for reminder job):
```python
from datetime import datetime, timedelta

now = datetime.utcnow()
tasks = session.exec(
    select(Task)
    .where(Task.completed == False)
    .where(Task.due_date != None)
    .where(Task.reminder_offset_minutes != None)
).all()

# Filter in Python (more complex logic)
for task in tasks:
    reminder_time = task.due_date - timedelta(minutes=task.reminder_offset_minutes)
    if now >= reminder_time:
        # Create notification
        pass
```

**6. Get unread notifications**:
```python
notifications = session.exec(
    select(Notification)
    .where(Notification.user_id == user_id)
    .where(Notification.read == False)
    .order_by(Notification.created_at.desc())
).all()
```

---

## Database Performance Considerations

**Indexes** (already defined above):
- `tasks.user_id`: Most common filter
- `tasks.completed`: Frequently used in status filters
- `tasks.due_date`: Critical for reminder job
- `tasks.tags` (GIN index): Enables fast JSONB queries
- `notifications.user_id, read` (composite): Optimizes "get unread" query

**Query Optimization**:
- Use `select(Task).where(...)` instead of loading all tasks and filtering in Python
- Pagination: If >100 tasks, add `LIMIT` and `OFFSET` (not required in Phase II)
- Connection pooling: Neon provides this via `-pooler` endpoint

**Estimated Data Size** (Phase II):
- Users: ~100 (hackathon demo)
- Tasks per user: ~50
- Total tasks: ~5,000
- Notifications: ~500 (active reminders)
- **Total DB size**: <10 MB (well within Neon free tier)

---

## Next Steps

This data model is now ready for:
1. **API contract generation** (OpenAPI schema in `/contracts/`)
2. **SQLModel implementation** (backend codebase)
3. **Frontend TypeScript types** (generated from OpenAPI)
4. **Database migrations** (Alembic setup)

All entities validated against functional requirements (FR-001 through FR-044) and success criteria (SC-001 through SC-020).
